<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Snowball Collector</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #add8e6;
        }

        canvas {
            display: block;
            user-select: none;
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: black;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-family: sans-serif;
            font-size: 16px;
            z-index: 10;
            /* Ensure HUD is above joystick */
        }

        /* --- Virtual Joystick Styles --- */
        #joystick-container {
            position: fixed;
            bottom: 30px;
            /* --- Move to Center --- */
            left: 50%;
            transform: translateX(-50%);
            /* Center horizontally */
            /* --- End Move to Center --- */
            width: 120px;
            height: 120px;
            display: none;
            z-index: 5;
        }

        #joystick-base {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(128, 128, 128, 0.5);
            /* Semi-transparent grey */
            border-radius: 50%;
            left: 0;
            top: 0;
        }

        #joystick-handle {
            position: absolute;
            width: 60px;
            /* Size of the handle */
            height: 60px;
            background-color: rgba(80, 80, 80, 0.8);
            /* Darker grey handle */
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            /* Center the handle */
            pointer-events: none;
            /* Prevent handle from stealing touch events */
        }

        /* Show joystick only on likely touch devices */
        @media (hover: none) and (pointer: coarse) {
            #joystick-container {
                display: block;
            }
        }

        /* --- End Joystick Styles --- */
    </style>
</head>

<body>
    <div id="game-container"></div>
    <div id="hud">Snow Collected: 0 / 0</div>

    <!-- Joystick HTML Elements -->
    <div id="joystick-container">
        <div id="joystick-base"></div>
        <div id="joystick-handle"></div>
    </div>
    <!-- End Joystick -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.165.0/three.module.min.js"></script>

    <script type="module">
        // Import Three.js
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.165.0/three.module.min.js';

        // === Phase 1: Basic Scene Setup ===
        let scene, camera, renderer, clock;
        let directionalLight;
        const gameContainer = document.getElementById('game-container');
        const hudElement = document.getElementById('hud');
        // --- Joystick Elements ---
        const joystickContainer = document.getElementById('joystick-container');
        const joystickBase = document.getElementById('joystick-base');
        const joystickHandle = document.getElementById('joystick-handle');
        // --- End Joystick ---


        // Game State
        let isGameOver = false;
        let isGameWon = false;
        // let useGyroControls = false; // REMOVED
        // let initialInteractionDone = false; // REMOVED

        // === Constants ===
        const GROUND_SIZE = 150;
        const INITIAL_SNOWBALL_RADIUS = 1;
        const MAX_SNOWBALL_RADIUS = 10;
        const MIN_SNOWBALL_RADIUS = 0.5;
        const SNOW_PATCH_COUNT = 30;
        const WARM_PATCH_COUNT = 15;
        const OBSTACLE_COUNT = 40;
        const KEYBOARD_TURN_SPEED = Math.PI / 2;
        const KEYBOARD_MOVE_ACCELERATION = 50;
        // --- Add Joystick Specific Speed ---
        const JOYSTICK_TURN_SPEED = Math.PI * 1.2; // INCREASED turn speed for joystick (adjust as needed)
        // --- End Joystick Specific Speed ---
        // const GYRO_TURN_SENSITIVITY = Math.PI / 4; // REMOVED
        // const GYRO_MOVE_SENSITIVITY = 2; // REMOVED
        // const VIRTUAL_JOYSTICK_SENSITIVITY = 1.0; // Adjust sensitivity (1 = full range)

        // --- Adjust Joystick Sensitivity ---
        const VIRTUAL_JOYSTICK_SENSITIVITY = 1.2; // INCREASED sensitivity (try 1.2, 1.5, or 2.0)
        const JOYSTICK_DEAD_ZONE = 0.1; // Ignore input if normalized distance is less than this (10%)
        // --- End Adjustments ---

        const LASER_COLOR = 0xff0000; // Red
        const LASER_LENGTH = 3.0;     // How far the laser extends (relative to base radius 1)
        const LASER_RADIUS = 0.03;    // How thick the laser is

        const FRICTION = 0.96;
        const MELT_RATE = 0.2;
        const COLLECT_GROWTH_FACTOR = 0.15 // 0.05;

        // === Player State ===
        let snowball;
        let snowballRadius = INITIAL_SNOWBALL_RADIUS;
        let snowballVelocity = new THREE.Vector3();
        const snowballMovement = {
            forward: 0,
            turn: 0
        };

        // === Input State ===
        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
        };
        // let gyro = { beta: 0, gamma: 0 }; // REMOVED

        // --- Joystick State ---
        let joystickActive = false;
        let joystickStartX = 0;
        let joystickStartY = 0;
        let joystickRadius = joystickBase.offsetWidth / 2; // Radius of the base circle
        // --- End Joystick State ---

        // === Game Objects ===
        let collectableSnow = [];
        let totalSnowPatches = 0;
        let currentSnowCollected = 0;
        let warmPatches = [];
        let obstacles = [];

        // === Textures ===
        const textureLoader = new THREE.TextureLoader();
        // Replace comments with actual Base64 Data URIs or file paths
        const snowTexture = textureLoader.load('snow.png'); // Placeholder
        const warmGroundTexture = textureLoader.load('lava.png'); // Placeholder
        const dirtTexture = textureLoader.load('ground.png'); // Placeholder

        function configureTexture(texture, repeatX, repeatY) {
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(repeatX, repeatY);
            return texture;
        }
        configureTexture(snowTexture, 30, 30);

        init();
        animate();

        function init() {
            clock = new THREE.Clock();
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xadd8e6);
            scene.fog = new THREE.Fog(0xadd8e6, 50, GROUND_SIZE * 0.8);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 15);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            gameContainer.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(30, 50, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            const shadowCamSize = GROUND_SIZE / 2;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 150;
            directionalLight.shadow.camera.left = -shadowCamSize;
            directionalLight.shadow.camera.right = shadowCamSize;
            directionalLight.shadow.camera.top = shadowCamSize;
            directionalLight.shadow.camera.bottom = -shadowCamSize;
            scene.add(directionalLight);

            createGround();
            createWarmPatches();
            createObstacles();
            createCollectableSnow(); // Creates patches with larger size from previous step
            updateHUD();
            createSnowball(); // Creates snowball with nose indicator from previous step
            setupControls(); // Sets up keyboard AND joystick

            window.addEventListener('resize', onWindowResize);

            // Update joystick radius on resize potentially
            window.addEventListener('resize', () => {
                joystickRadius = joystickBase.offsetWidth / 2;
            });
        }

        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(GROUND_SIZE, GROUND_SIZE);
            const groundMaterial = new THREE.MeshStandardMaterial({ map: snowTexture, roughness: 0.8, metalness: 0.1 });
            const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);
        }

        function createWarmPatches() {
            // --- Constants for Warm Patch Shape ---
            const baseWarmPatchRadius = 4.5; // Base average size (was the CircleGeometry radius)
            const warmPatchSegments = 16;    // Detail level
            const minWarmRadiusFactor = 0.6; // More variation maybe? (60%)
            const maxWarmRadiusFactor = 1.4; // More variation maybe? (140%)
            // --- End Constants ---

            const patchMaterial = new THREE.MeshStandardMaterial({
                map: warmGroundTexture,
                roughness: 0.9,
                side: THREE.DoubleSide // Good practice for modified geometry
            });

            for (let i = 0; i < WARM_PATCH_COUNT; i++) {
                // --- Create Base Geometry ---
                const patchGeometry = new THREE.CircleGeometry(baseWarmPatchRadius, warmPatchSegments);

                // --- Modify Vertices for Organic Shape ---
                const positions = patchGeometry.attributes.position;
                const vertex = new THREE.Vector3();

                for (let j = 0; j < positions.count; j++) {
                    vertex.fromBufferAttribute(positions, j);
                    const distance = vertex.length();

                    if (distance > 0.001) { // Skip center vertex
                        const randomFactor = THREE.MathUtils.randFloat(minWarmRadiusFactor, maxWarmRadiusFactor);
                        const newDistance = baseWarmPatchRadius * randomFactor;
                        vertex.normalize().multiplyScalar(newDistance);
                        positions.setXYZ(j, vertex.x, vertex.y, vertex.z);
                    }
                }
                positions.needsUpdate = true;
                patchGeometry.computeVertexNormals(); // Recalculate normals for standard material
                // --- End Modify Vertices ---


                const patch = new THREE.Mesh(patchGeometry, patchMaterial);
                const range = GROUND_SIZE * 0.45;
                patch.position.set(
                    (Math.random() - 0.5) * range * 2,
                    0.01, // Slightly above ground
                    (Math.random() - 0.5) * range * 2
                );
                patch.rotation.x = -Math.PI / 2; // Align with ground
                patch.receiveShadow = true; // Still receive shadows
                scene.add(patch);
                warmPatches.push(patch);
            }
        }

        function createObstacles() {
            const rockGeometry = new THREE.IcosahedronGeometry(0.8, 0);
            const rockMaterial = new THREE.MeshStandardMaterial({ map: dirtTexture, roughness: 0.8 });
            const treeTrunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2.5, 8);
            const treeTrunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const treeLeavesGeometry = new THREE.ConeGeometry(1.2, 3, 8);
            const treeLeavesMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });

            for (let i = 0; i < OBSTACLE_COUNT; i++) {
                const isTree = Math.random() > 0.4;
                const range = GROUND_SIZE * 0.45;
                const x = (Math.random() - 0.5) * range * 2;
                const z = (Math.random() - 0.5) * range * 2;
                let obstacleMesh;
                if (isTree) {
                    const tree = new THREE.Group();
                    const trunk = new THREE.Mesh(treeTrunkGeometry, treeTrunkMaterial);
                    trunk.position.y = 1.25; trunk.castShadow = true; trunk.receiveShadow = true;
                    const leaves = new THREE.Mesh(treeLeavesGeometry, treeLeavesMaterial);
                    leaves.position.y = 2.5 + 1.5 - 0.5; leaves.castShadow = true; leaves.receiveShadow = true;
                    tree.add(trunk); tree.add(leaves);
                    tree.position.set(x, 0, z); scene.add(tree);
                    obstacleMesh = tree;
                    obstacleMesh.userData.radius = 0.5;
                    obstacleMesh.userData.center = new THREE.Vector3(x, 0.5, z);
                } else {
                    const rockScale = 0.5 + Math.random() * 1.5;
                    const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                    rock.scale.set(rockScale, rockScale * (0.8 + Math.random() * 0.4), rockScale);
                    rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                    const rockRadius = rockScale * 0.8;
                    rock.position.set(x, rockRadius * 0.8, z);
                    rock.castShadow = true; rock.receiveShadow = true; scene.add(rock);
                    obstacleMesh = rock;
                    obstacleMesh.userData.radius = rockRadius;
                    obstacleMesh.userData.center = rock.position.clone();
                }
                obstacles.push(obstacleMesh);
            }
        }

        // Uses larger patch size from previous step
        function createCollectableSnow() {
            // Base size for the organic patches before randomization
            const basePatchRadius = 1.2; // Average radius (adjust as needed)
            const patchSegments = 16; // Controls the detail/roundness (12-24 is good)
            const minRadiusFactor = 0.7; // Minimum distance factor (e.g., 70% of base radius)
            const maxRadiusFactor = 1.3; // Maximum distance factor (e.g., 130% of base radius)

            const patchMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide // Render both sides in case normals get weird
            });

            for (let i = 0; i < SNOW_PATCH_COUNT; i++) {
                // --- Create Base Geometry ---
                const patchGeometry = new THREE.CircleGeometry(basePatchRadius, patchSegments);

                // --- Modify Vertices for Organic Shape ---
                const positions = patchGeometry.attributes.position;
                const vertex = new THREE.Vector3(); // Temporary vector for calculations

                for (let j = 0; j < positions.count; j++) {
                    vertex.fromBufferAttribute(positions, j);

                    // Calculate distance from center (original radius for this vertex)
                    const distance = vertex.length();

                    // Don't modify the center vertex (distance is 0)
                    if (distance > 0.001) {
                        // Generate a random scaling factor for the radius
                        const randomFactor = THREE.MathUtils.randFloat(minRadiusFactor, maxRadiusFactor);
                        const newDistance = basePatchRadius * randomFactor; // Scale relative to base radius

                        // Calculate new position: Normalize original vector and scale by new distance
                        vertex.normalize().multiplyScalar(newDistance);

                        // Update the position buffer
                        positions.setXYZ(j, vertex.x, vertex.y, vertex.z);
                    }
                }
                positions.needsUpdate = true; // Tell Three.js the buffer has changed
                patchGeometry.computeVertexNormals(); // Recalculate normals for potentially better lighting/appearance (though basic material ignores it)
                // --- End Modify Vertices ---

                const patch = new THREE.Mesh(patchGeometry, patchMaterial);
                const range = GROUND_SIZE * 0.48;
                patch.position.set(
                    (Math.random() - 0.5) * range * 2,
                    0.02, // Slightly higher than warm patches
                    (Math.random() - 0.5) * range * 2
                );
                patch.rotation.x = -Math.PI / 2; // Rotate to lie flat
                scene.add(patch);
                collectableSnow.push(patch);
            }
            totalSnowPatches = collectableSnow.length;
        }

        // Uses nose indicator from previous step
        function createSnowball() {
            const snowballGeometry = new THREE.SphereGeometry(1, 32, 16); // Base radius 1 for easy scaling
            const snowballMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.6,
                metalness: 0.0
            });
            snowball = new THREE.Mesh(snowballGeometry, snowballMaterial);
            snowball.castShadow = true;

            // --- REMOVE Nose Indicator ---
            // const noseRadius = 0.2;
            // const noseGeometry = new THREE.SphereGeometry(noseRadius, 12, 8);
            // const noseMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8 });
            // const noseMesh = new THREE.Mesh(noseGeometry, noseMaterial);
            // noseMesh.position.set(0, 0, 1.0 - noseRadius * 0.5);
            // noseMesh.castShadow = true;
            // snowball.add(noseMesh);
            // --- End Remove Nose ---

            // --- Create the Laser Pointer ---
            const laserGeometry = new THREE.CylinderGeometry(
                LASER_RADIUS, // radiusTop
                LASER_RADIUS, // radiusBottom
                LASER_LENGTH, // height
                8             // radialSegments (low is fine for thin cylinder)
            );
            // Use MeshBasicMaterial so it's bright red regardless of lighting
            const laserMaterial = new THREE.MeshBasicMaterial({
                color: LASER_COLOR
            });
            const laserMesh = new THREE.Mesh(laserGeometry, laserMaterial);

            // Rotate the cylinder so its length points along the snowball's local Z axis (forward)
            // By default, cylinder height is along local Y
            laserMesh.rotation.x = Math.PI / 2;

            // Position the laser's center.
            // It should start near the surface (radius 1 in local space) and extend forward.
            // The cylinder's center is at half its length.
            laserMesh.position.set(
                0,
                0,
                1.0 + LASER_LENGTH / 2 // Place center forward from surface (radius 1)
            );

            // Disable shadows for the laser itself (optional, it likely won't cast noticeable shadows anyway)
            laserMesh.castShadow = false;
            laserMesh.receiveShadow = false;

            // Add the laser as a child of the snowball
            snowball.add(laserMesh);
            // --- End Laser Pointer ---


            // Set initial position and scale based on starting radius
            snowball.position.set(0, INITIAL_SNOWBALL_RADIUS, 0);
            snowball.scale.set(INITIAL_SNOWBALL_RADIUS, INITIAL_SNOWBALL_RADIUS, INITIAL_SNOWBALL_RADIUS);
            scene.add(snowball);
            camera.lookAt(snowball.position); // Initial lookAt
        }

        function setupControls() {
            // Keyboard
            window.addEventListener('keydown', (event) => {
                if (keys.hasOwnProperty(event.key)) keys[event.key] = true;
            });
            window.addEventListener('keyup', (event) => {
                if (keys.hasOwnProperty(event.key)) keys[event.key] = false;
            });

            // --- Virtual Joystick Listeners ---
            joystickBase.addEventListener('touchstart', handleTouchStart, { passive: false });
            joystickBase.addEventListener('touchmove', handleTouchMove, { passive: false });
            joystickBase.addEventListener('touchend', handleTouchEnd);
            joystickBase.addEventListener('touchcancel', handleTouchEnd); // Treat cancel like end
            // --- End Joystick Listeners ---

            // REMOVED Gyro activation button listener
        }

        // --- Joystick Touch Handlers ---
        function handleTouchStart(event) {
            event.preventDefault(); // Prevent page scroll/zoom
            if (event.touches.length > 0) {
                joystickActive = true;
                const touch = event.touches[0];
                // Record start relative to the joystick base element's center
                const rect = joystickBase.getBoundingClientRect();
                joystickStartX = rect.left + rect.width / 2;
                joystickStartY = rect.top + rect.height / 2;

                // Initial move calculation (optional, can start from center)
                calculateJoystickMovement(touch.clientX, touch.clientY);
            }
        }

        function handleTouchMove(event) {
            event.preventDefault();
            if (!joystickActive || event.touches.length === 0) return;
            const touch = event.touches[0];
            calculateJoystickMovement(touch.clientX, touch.clientY);
        }

        function handleTouchEnd(event) {
            // No preventDefault needed here usually
            if (joystickActive) {
                joystickActive = false;
                // Reset handle position and movement values
                joystickHandle.style.transform = `translate(-50%, -50%)`; // Center it
                snowballMovement.forward = 0;
                snowballMovement.turn = 0;
            }
        }

        // In calculateJoystickMovement function:
        function calculateJoystickMovement(currentX, currentY) {
            const dx = currentX - joystickStartX;
            const dy = currentY - joystickStartY;
            let distance = Math.sqrt(dx * dx + dy * dy);

            const normalizedX = distance === 0 ? 0 : dx / distance;
            const normalizedY = distance === 0 ? 0 : dy / distance;

            // Calculate visual handle position (clamped)
            const visualDistance = Math.min(distance, joystickRadius);
            const visualX = normalizedX * visualDistance;
            const visualY = normalizedY * visualDistance;
            joystickHandle.style.transform = `translate(calc(-50% + ${visualX}px), calc(-50% + ${visualY}px))`;

            // Calculate Input Values with Dead Zone
            let inputDistanceNormalized = distance / joystickRadius;

            if (inputDistanceNormalized < JOYSTICK_DEAD_ZONE) {
                snowballMovement.forward = 0;
                snowballMovement.turn = 0;
            } else {
                // Calculate scale from dead zone edge to full radius
                let effectiveInputScale = (inputDistanceNormalized - JOYSTICK_DEAD_ZONE) / (1 - JOYSTICK_DEAD_ZONE);
                // Apply sensitivity and clamp
                effectiveInputScale = Math.min(effectiveInputScale * VIRTUAL_JOYSTICK_SENSITIVITY, 1.0);

                // --- Apply Quadratic Easing ---
                // This makes small stick movements result in even smaller input values,
                // allowing for finer control near the center.
                let easedScale = effectiveInputScale * effectiveInputScale;
                // --- End Easing ---

                // Map normalized direction vector components by the *eased* scale
                snowballMovement.forward = Math.max(-1, Math.min(1, -normalizedY * easedScale));
                // Stick Right = Positive X = Negative Turn
                snowballMovement.turn = Math.max(-1, Math.min(1, -normalizedX * easedScale));
            }
        }
        // --- End Joystick Touch Handlers ---

        // REMOVED handleOrientation
        // REMOVED requestGyroPermission

        // In updateSnowballMovement function:
        function updateSnowballMovement(deltaTime) {
            if (isGameOver || isGameWon) {
                snowballMovement.forward = 0;
                snowballMovement.turn = 0;
                snowballVelocity.multiplyScalar(FRICTION * FRICTION);
                return;
            }

            let isUsingJoystick = joystickActive;

            if (!isUsingJoystick) {
                snowballMovement.forward = 0;
                snowballMovement.turn = 0;
                if (keys.ArrowUp) snowballMovement.forward = 1;
                if (keys.ArrowDown) snowballMovement.forward = -1;
                if (keys.ArrowLeft) snowballMovement.turn = 1;  // Positive turn = Left
                if (keys.ArrowRight) snowballMovement.turn = -1; // Negative turn = Right
            }

            // Apply Rotation using appropriate speed
            const currentTurnSpeed = isUsingJoystick ? JOYSTICK_TURN_SPEED : KEYBOARD_TURN_SPEED;
            // Positive turn value results in counter-clockwise rotation (Left)
            // Negative turn value results in clockwise rotation (Right)
            snowball.rotation.y += snowballMovement.turn * currentTurnSpeed * deltaTime;

            // Apply Acceleration (Forward movement)
            const forwardDirection = new THREE.Vector3();
            snowball.getWorldDirection(forwardDirection);
            forwardDirection.y = 0;
            forwardDirection.normalize();

            const accelerationValue = snowballMovement.forward * KEYBOARD_MOVE_ACCELERATION;
            const accelerationVector = forwardDirection.multiplyScalar(accelerationValue * deltaTime);
            snowballVelocity.add(accelerationVector);

            // Apply Friction
            snowballVelocity.multiplyScalar(FRICTION);

            // Collision/Position Update
            const oldPosition = snowball.position.clone();
            snowball.position.addScaledVector(snowballVelocity, deltaTime);
            snowball.position.y = snowballRadius;
            handleObstacleCollisions(oldPosition);
            const halfGround = GROUND_SIZE / 2 - snowballRadius;
            snowball.position.x = Math.max(-halfGround, Math.min(halfGround, snowball.position.x));
            snowball.position.z = Math.max(-halfGround, Math.min(halfGround, snowball.position.z));
        }

        function handleObstacleCollisions(oldPosition) {
            const snowballWorldPos = snowball.position;
            for (const obstacle of obstacles) {
                if (!obstacle.userData.center || !obstacle.userData.radius) continue;
                const obstacleCenter = obstacle.userData.center;
                const obstacleRadius = obstacle.userData.radius;
                const dx = snowballWorldPos.x - obstacleCenter.x;
                const dz = snowballWorldPos.z - obstacleCenter.z;
                const distanceSq = dx * dx + dz * dz;
                const radiiSumSq = (snowballRadius + obstacleRadius) * (snowballRadius + obstacleRadius);

                if (distanceSq < radiiSumSq) {
                    const collisionNormal = new THREE.Vector3(dx, 0, dz).normalize();
                    const dot = snowballVelocity.dot(collisionNormal);
                    if (dot < 0) {
                        const counterVector = collisionNormal.multiplyScalar(-dot);
                        snowballVelocity.add(counterVector);
                    }
                    const overlap = (snowballRadius + obstacleRadius) - Math.sqrt(distanceSq);
                    const pushVector = collisionNormal.clone().multiplyScalar(overlap * 0.51); // Slightly more push
                    snowball.position.add(pushVector);
                    snowball.position.y = snowballRadius;
                    break;
                }
            }
        }

        // Uses updated collision check from previous step
        function checkCollectionsAndHazards(deltaTime) {
            if (isGameOver || isGameWon) return;

            const snowballPos = snowball.position;

            // === Phase 4: Snow Collection Logic ===
            // --- Adjust Collision Radius to Approximate Organic Shape ---
            // Use the average/base radius used during geometry creation
            const patchRadius = 1.2; // Matches basePatchRadius used in createCollectableSnow
            // --- End Adjust ---

            for (let i = collectableSnow.length - 1; i >= 0; i--) {
                const patch = collectableSnow[i];
                const dx = snowballPos.x - patch.position.x;
                const dz = snowballPos.z - patch.position.z;
                const distanceSq = dx * dx + dz * dz;
                const radiiSum = snowballRadius + patchRadius;

                if (distanceSq < radiiSum * radiiSum) {
                    // --- Dispose Geometry when removing ---
                    // Good practice if creating/destroying many geometries
                    if (patch.geometry) {
                        patch.geometry.dispose();
                    }
                    if (patch.material) {
                        // Material might be shared, but if unique per patch:
                        // patch.material.dispose();
                    }
                    // --- End Dispose ---

                    scene.remove(patch);
                    collectableSnow.splice(i, 1);
                    currentSnowCollected++;

                    const growth = COLLECT_GROWTH_FACTOR * (1 + currentSnowCollected / totalSnowPatches);
                    snowballRadius = Math.min(snowballRadius + growth, MAX_SNOWBALL_RADIUS);
                    updateSnowballSize();
                    updateHUD();

                    if (currentSnowCollected >= totalSnowPatches) {
                        winGame(); return;
                    }
                }
            }

            // === Phase 6: Hazard Mechanic (Melting) ===
            let isMelting = false;
            const warmPatchCollisionRadius = 4.5; // Unchanged
            for (const patch of warmPatches) {
                const dx = snowballPos.x - patch.position.x;
                const dz = snowballPos.z - patch.position.z;
                const distanceSq = dx * dx + dz * dz;
                const radiiSum = snowballRadius + warmPatchCollisionRadius;
                if (distanceSq < radiiSum * radiiSum) {
                    isMelting = true; break;
                }
            }
            if (isMelting) {
                snowballRadius = Math.max(snowballRadius - MELT_RATE * deltaTime, MIN_SNOWBALL_RADIUS);
                updateSnowballSize();
            }
        }

        function updateSnowballSize() {
            snowball.scale.set(snowballRadius, snowballRadius, snowballRadius);
            snowball.position.y = snowballRadius;
        }

        function updateCamera() {
            if (!snowball) return;
            const offset = new THREE.Vector3(0, 8 + snowballRadius * 2, 12 + snowballRadius * 2);
            const desiredPosition = snowball.position.clone().add(offset);
            camera.position.lerp(desiredPosition, 0.05);
            camera.lookAt(snowball.position);
        }

        function updateHUD() {
            if (isGameWon) {
                hudElement.innerText = `You Win! Collected ${currentSnowCollected} / ${totalSnowPatches}`;
            } else if (isGameOver) {
                hudElement.innerText = `Game Over!`;
            } else {
                hudElement.innerText = `Snow Collected: ${currentSnowCollected} / ${totalSnowPatches} | Radius: ${snowballRadius.toFixed(1)}`;
            }
        }

        function winGame() {
            console.log("You Win!");
            isGameWon = true;
            updateHUD();
            snowballVelocity.set(0, 0, 0);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            // Update joystick radius calculation in case size changes relative to window
            joystickRadius = joystickBase.offsetWidth / 2;
        }

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            if (snowball) {
                updateSnowballMovement(deltaTime); // Handles both keyboard and joystick now
                checkCollectionsAndHazards(deltaTime);
            }
            updateCamera();
            render();
        }

        function render() {
            renderer.render(scene, camera);
        }

    </script>
</body>

</html>
