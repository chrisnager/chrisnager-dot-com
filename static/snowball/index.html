<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Snowball Collector</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #add8e6;
        }

        canvas {
            display: block;
            user-select: none;
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: black;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-family: sans-serif;
            font-size: 16px;
            z-index: 10;
            /* Ensure HUD is above joystick */
        }

        /* --- Virtual Joystick Styles --- */
        #joystick-container {
            position: fixed;
            bottom: 30px;
            /* --- Move to Center --- */
            left: 50%;
            transform: translateX(-50%);
            /* Center horizontally */
            /* --- End Move to Center --- */
            width: 120px;
            height: 120px;
            display: none;
            z-index: 5;
        }

        #joystick-base {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(128, 128, 128, 0.5);
            /* Semi-transparent grey */
            border-radius: 50%;
            left: 0;
            top: 0;
        }

        #joystick-handle {
            position: absolute;
            width: 60px;
            /* Size of the handle */
            height: 60px;
            background-color: rgba(80, 80, 80, 0.8);
            /* Darker grey handle */
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            /* Center the handle */
            pointer-events: none;
            /* Prevent handle from stealing touch events */
        }

        /* Show joystick only on likely touch devices */
        @media (hover: none) and (pointer: coarse) {
            #joystick-container {
                display: block;
            }
        }

        /* --- End Joystick Styles --- */
    </style>
</head>

<body>
    <div id="game-container"></div>
    <div id="hud">Snow Collected: 0 / 0</div>

    <!-- Joystick HTML Elements -->
    <div id="joystick-container">
        <div id="joystick-base"></div>
        <div id="joystick-handle"></div>
    </div>
    <!-- End Joystick -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.165.0/three.module.min.js"></script>

    <script type="module">
        // Import Three.js
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.165.0/three.module.min.js';

        // === Phase 1: Basic Scene Setup ===
        let scene, camera, renderer, clock;
        let directionalLight;
        const gameContainer = document.getElementById('game-container');
        const hudElement = document.getElementById('hud');
        // --- Joystick Elements ---
        const joystickContainer = document.getElementById('joystick-container');
        const joystickBase = document.getElementById('joystick-base');
        const joystickHandle = document.getElementById('joystick-handle');
        // --- End Joystick ---


        // Game State
        let isGameOver = false;
        let isGameWon = false;
        // let useGyroControls = false; // REMOVED
        // let initialInteractionDone = false; // REMOVED

        // === Constants ===
        const GROUND_SIZE = 150;
        const INITIAL_SNOWBALL_RADIUS = 1;
        const MAX_SNOWBALL_RADIUS = 10;
        const MIN_SNOWBALL_RADIUS = 0.5;
        const SNOW_PATCH_COUNT = 30;
        const WARM_PATCH_COUNT = 15;
        const OBSTACLE_COUNT = 40;
        const KEYBOARD_TURN_SPEED = Math.PI / 2;
        const KEYBOARD_MOVE_ACCELERATION = 50;
        // --- Add Joystick Specific Speed ---
        const JOYSTICK_TURN_SPEED = Math.PI * 1.2; // INCREASED turn speed for joystick (adjust as needed)
        // --- End Joystick Specific Speed ---
        // const GYRO_TURN_SENSITIVITY = Math.PI / 4; // REMOVED
        // const GYRO_MOVE_SENSITIVITY = 2; // REMOVED
        // const VIRTUAL_JOYSTICK_SENSITIVITY = 1.0; // Adjust sensitivity (1 = full range)

        // --- Adjust Joystick Sensitivity ---
        const VIRTUAL_JOYSTICK_SENSITIVITY = 1.2; // INCREASED sensitivity (try 1.2, 1.5, or 2.0)
        const JOYSTICK_DEAD_ZONE = 0.1; // Ignore input if normalized distance is less than this (10%)
        // --- End Adjustments ---

        const LASER_COLOR = 0xff0000; // Red
        const LASER_LENGTH = 3.0;     // How far the laser extends (relative to base radius 1)
        const LASER_RADIUS = 0.03;    // How thick the laser is

        const FRICTION = 0.96;
        const MELT_RATE = 0.2;
        const COLLECT_GROWTH_FACTOR = 0.15 // 0.05;

        // --- Static Snowball Constants ---
        const STATIC_SNOWBALL_COUNT = 15;
        const MIN_STATIC_RADIUS = 0.8;
        const MAX_STATIC_RADIUS = 5.0; // Allow them to be potentially larger than player's initial max
        // --- End Static Snowball Constants ---

        // --- Obstacle Interaction Constants ---
        const CRUSH_SIZE_MULTIPLIER = 2.5; // Player radius must be this many times > obstacle radius to crush
        const LOG_CRUSH_MULTIPLIER = 4.0; // Logs might need a higher multiplier or be indestructible
        const OBSTACLE_CRUSH_EFFECT = true; // (Optional) Placeholder for future effects
        // --- End Obstacle Interaction ---

        // --- AI Snowball Constants ---
        const AI_SNOWBALL_COUNT = 15; // Renamed from STATIC_SNOWBALL_COUNT
        const MIN_AI_RADIUS = 0.8;    // Renamed from MIN_STATIC_RADIUS
        const MAX_AI_RADIUS = 5.0;    // Renamed from MAX_STATIC_RADIUS
        const AI_TURN_SPEED = Math.PI * 0.8; // How fast AI turns towards target
        const AI_ACCELERATION = 30;    // How fast AI gains speed
        const AI_FRICTION = 0.95;      // Friction for AI movement
        const AI_MAX_SPEED = 8;        // Max speed AI will move
        const AI_WANDER_MIN_TIME = 3.0; // Min seconds before picking new target
        const AI_WANDER_MAX_TIME = 8.0; // Max seconds before picking new target
        const AI_OBSTACLE_AVOID_STRENGTH = 1.5; // How strongly AI steers away
        // --- End AI Snowball Constants ---

        // === Player State ===
        let snowball;
        let snowballRadius = INITIAL_SNOWBALL_RADIUS;
        let snowballVelocity = new THREE.Vector3();
        const snowballMovement = {
            forward: 0,
            turn: 0
        };

        // === Input State ===
        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
        };
        // let gyro = { beta: 0, gamma: 0 }; // REMOVED

        // --- Joystick State ---
        let joystickActive = false;
        let joystickStartX = 0;
        let joystickStartY = 0;
        let joystickRadius = joystickBase.offsetWidth / 2; // Radius of the base circle
        // --- End Joystick State ---

        // === Game Objects ===
        let collectableSnow = [];
        let totalSnowPatches = 0;
        let currentSnowCollected = 0;
        let warmPatches = [];
        let obstacles = [];
        let aiSnowballs = []; // Renamed from staticSnowballs

        // === Textures ===
        const textureLoader = new THREE.TextureLoader();
        // Replace comments with actual Base64 Data URIs or file paths
        const snowTexture = textureLoader.load('dimple.png'); // Placeholder
        const warmGroundTexture = textureLoader.load('lava.png'); // Placeholder
        const dirtTexture = textureLoader.load('ground.png'); // Placeholder

        function configureTexture(texture, repeatX, repeatY) {
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(repeatX, repeatY);
            return texture;
        }
        configureTexture(snowTexture, 30, 30);

        init();
        animate();

        function init() {
            clock = new THREE.Clock();
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xadd8e6);
            scene.fog = new THREE.Fog(0xadd8e6, 50, GROUND_SIZE * 0.8);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 15);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            gameContainer.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(30, 50, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            const shadowCamSize = GROUND_SIZE / 2;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 150;
            directionalLight.shadow.camera.left = -shadowCamSize;
            directionalLight.shadow.camera.right = shadowCamSize;
            directionalLight.shadow.camera.top = shadowCamSize;
            directionalLight.shadow.camera.bottom = -shadowCamSize;
            scene.add(directionalLight);

            createGround();
            createWarmPatches();
            createObstacles();
            createCollectableSnow(); // Creates patches with larger size from previous step
            createAISnowballs();
            updateHUD();
            createSnowball(); // Creates snowball with nose indicator from previous step
            setupControls(); // Sets up keyboard AND joystick

            window.addEventListener('resize', onWindowResize);

            // Update joystick radius on resize potentially
            window.addEventListener('resize', () => {
                joystickRadius = joystickBase.offsetWidth / 2;
            });
        }

        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(GROUND_SIZE, GROUND_SIZE);
            const groundMaterial = new THREE.MeshStandardMaterial({ map: snowTexture, roughness: 0.8, metalness: 0.1 });
            const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);
        }

        function updateAISnowballs(deltaTime) {
            const targetDirection = new THREE.Vector3();
            const currentDirection = new THREE.Vector3();
            const desiredVelocity = new THREE.Vector3();

            for (let i = 0; i < aiSnowballs.length; i++) {
                const aiBall = aiSnowballs[i];
                const data = aiBall.userData;
                if (!data || data.radius === undefined) continue; // Skip if missing data

                // Decrement wander timer
                data.aiWanderTimer -= deltaTime;

                // --- AI Decision Making (Wandering) ---
                const distToTargetSq = aiBall.position.distanceToSquared(data.aiTargetPos);
                // Pick new target if timer runs out OR close to current target OR target is invalid (0,0,0)
                if (data.aiWanderTimer <= 0 || distToTargetSq < 25 || data.aiTargetPos.lengthSq() < 0.1) {
                    const wanderRange = GROUND_SIZE * 0.48;
                    data.aiTargetPos.set(
                        (Math.random() - 0.5) * wanderRange * 2,
                        data.radius, // Target Y should be its own radius
                        (Math.random() - 0.5) * wanderRange * 2
                    );
                    data.aiWanderTimer = THREE.MathUtils.randFloat(AI_WANDER_MIN_TIME, AI_WANDER_MAX_TIME);
                    // console.log(`AI ${i} new target: ${data.aiTargetPos.x.toFixed(1)}, ${data.aiTargetPos.z.toFixed(1)}`);
                }

                // --- Obstacle Avoidance Steering (Calculate Avoid Vector) ---
                calculateAIAvoidance(aiBall, data);

                // --- Movement Calculation ---
                // 1. Calculate direction to target
                targetDirection.subVectors(data.aiTargetPos, aiBall.position).normalize();

                // 2. Combine target direction with avoidance direction
                // Give avoidance more weight if it's active
                const avoidWeight = data.aiAvoidVector.lengthSq() > 0.01 ? AI_OBSTACLE_AVOID_STRENGTH : 0;
                desiredVelocity.copy(targetDirection).multiplyScalar(1.0 - avoidWeight * 0.5); // Slightly reduce target pull when avoiding
                desiredVelocity.addScaledVector(data.aiAvoidVector, avoidWeight); // Add avoidance steer
                desiredVelocity.normalize();

                // 3. Calculate Steering Rotation towards desired direction
                aiBall.getWorldDirection(currentDirection);
                const angleToTarget = Math.atan2(
                    currentDirection.x * desiredVelocity.z - currentDirection.z * desiredVelocity.x, // Cross product Y component
                    currentDirection.x * desiredVelocity.x + currentDirection.z * desiredVelocity.z  // Dot product
                );

                // Clamp turn speed
                const turn = Math.max(-1, Math.min(1, angleToTarget / (Math.PI * 0.1))) // Faster turn if angle is large
                    * AI_TURN_SPEED * deltaTime;
                aiBall.rotation.y += turn;

                // 4. Apply Acceleration along NEW forward direction
                aiBall.getWorldDirection(currentDirection); // Get updated direction after turning
                data.velocity.addScaledVector(currentDirection, AI_ACCELERATION * deltaTime);

                // 5. Apply Friction & Clamp Speed
                data.velocity.multiplyScalar(AI_FRICTION);
                if (data.velocity.lengthSq() > AI_MAX_SPEED * AI_MAX_SPEED) {
                    data.velocity.normalize().multiplyScalar(AI_MAX_SPEED);
                }

                // 6. Update Position
                aiBall.position.addScaledVector(data.velocity, deltaTime);

                // 7. Keep on ground & Clamp to bounds
                aiBall.position.y = data.radius;
                const halfGround = GROUND_SIZE / 2 - data.radius;
                aiBall.position.x = Math.max(-halfGround, Math.min(halfGround, aiBall.position.x));
                aiBall.position.z = Math.max(-halfGround, Math.min(halfGround, aiBall.position.z));

                // --- Update Scale (if radius changed due to melting/absorption) ---
                // Important: Check if scale already matches radius to avoid unnecessary updates
                if (Math.abs(aiBall.scale.x - data.radius) > 0.01) {
                    aiBall.scale.set(data.radius, data.radius, data.radius);
                }

                // --- Check Melting for AI ---
                checkAIHazards(aiBall, data, deltaTime);

            } // End AI loop

            // --- AI vs AI Collision/Absorption (after movement) ---
            for (let i = 0; i < aiSnowballs.length; i++) {
                const ai1 = aiSnowballs[i];
                if (!ai1.userData) continue;
                const r1 = ai1.userData.radius;

                for (let j = i + 1; j < aiSnowballs.length; j++) { // Check against others
                    const ai2 = aiSnowballs[j];
                    if (!ai2.userData) continue;
                    const r2 = ai2.userData.radius;

                    const distanceSq = ai1.position.distanceToSquared(ai2.position);
                    const radiiSum = r1 + r2;

                    if (distanceSq < radiiSum * radiiSum) {
                        // AI-AI Collision
                        if (r1 > r2) { // ai1 absorbs ai2
                            const growth = Math.max(0, r2 - INITIAL_SNOWBALL_RADIUS);
                            ai1.userData.radius = Math.min(r1 + growth, MAX_AI_RADIUS * 1.2); // Allow AI to get slightly bigger?
                            ai2.userData.radius = INITIAL_SNOWBALL_RADIUS; // Reset smaller one
                        } else { // ai2 absorbs ai1
                            const growth = Math.max(0, r1 - INITIAL_SNOWBALL_RADIUS);
                            ai2.userData.radius = Math.min(r2 + growth, MAX_AI_RADIUS * 1.2);
                            ai1.userData.radius = INITIAL_SNOWBALL_RADIUS; // Reset smaller one
                        }
                        // Scale/position update will happen in the next frame's main loop for these AIs
                        // console.log(`AI ${i} (${r1.toFixed(1)}) vs AI ${j} (${r2.toFixed(1)}) -> ${ai1.userData.radius.toFixed(1)} / ${ai2.userData.radius.toFixed(1)}`)
                    }
                }
            }
            // --- End AI vs AI ---

        } // End updateAISnowballs

        function calculateAIAvoidance(aiBall, data) {
            data.aiAvoidVector.set(0, 0, 0); // Reset avoidance vector
            const checkRadius = data.radius * 3.0; // How far ahead to check roughly
            const checkRadiusSq = checkRadius * checkRadius;

            for (const obstacle of obstacles) {
                if (!obstacle.userData || !obstacle.userData.center) continue;
                const obstacleCollisionRadius = obstacle.userData.collisionRadius || obstacle.userData.radius;
                if (obstacleCollisionRadius === undefined) continue;

                const vecToObstacle = new THREE.Vector3().subVectors(obstacle.userData.center, aiBall.position);
                const distToObstacleSq = vecToObstacle.x * vecToObstacle.x + vecToObstacle.z * vecToObstacle.z;

                // Only consider obstacles within check radius and roughly in front
                if (distToObstacleSq < checkRadiusSq + obstacleCollisionRadius * obstacleCollisionRadius) {
                    // Simple avoidance: steer away from obstacle center
                    // More weight if closer
                    const avoidanceStrength = 1.0 - (Math.sqrt(distToObstacleSq) / checkRadius);
                    data.aiAvoidVector.addScaledVector(vecToObstacle, -avoidanceStrength / (distToObstacleSq + 1.0)); // Add vector pointing away
                }
            }
            // Also avoid other AI snowballs (simplified)
            for (const otherAI of aiSnowballs) {
                if (otherAI === aiBall || !otherAI.userData) continue; // Skip self and invalid
                const vecToOther = new THREE.Vector3().subVectors(otherAI.position, aiBall.position);
                const distToOtherSq = vecToOther.lengthSq();
                if (distToOtherSq < checkRadiusSq * 0.5) { // Check closer range for other AI
                    const avoidanceStrength = 1.0 - (Math.sqrt(distToOtherSq) / (checkRadius * 0.7));
                    data.aiAvoidVector.addScaledVector(vecToOther, -avoidanceStrength / (distToOtherSq + 1.0));
                }
            }


            data.aiAvoidVector.normalize(); // Use normalized direction for steering
        }

        function checkAIHazards(aiBall, data, deltaTime) {
            // Melting check
            let isMelting = false;
            const warmPatchCollisionRadius = 4.5; // Radius of warm patches
            for (const patch of warmPatches) {
                const dx = aiBall.position.x - patch.position.x;
                const dz = aiBall.position.z - patch.position.z;
                const distanceSq = dx * dx + dz * dz;
                const radiiSum = data.radius + warmPatchCollisionRadius;
                if (distanceSq < radiiSum * radiiSum) {
                    isMelting = true;
                    break;
                }
            }

            if (isMelting) {
                // Decrease radius stored in userData
                data.radius = Math.max(data.radius - MELT_RATE * deltaTime * 0.5, MIN_SNOWBALL_RADIUS); // AI melts slightly slower?
                // Position and scale will be updated in main AI loop or next frame
            }
        }

        function createAISnowballs() {
            const snowballGeometry = new THREE.SphereGeometry(1, 24, 12);
            const snowballMaterial = new THREE.MeshStandardMaterial({
                map: snowTexture, // Apply texture
                roughness: 0.7,
                metalness: 0.0
            });

            for (let i = 0; i < AI_SNOWBALL_COUNT; i++) { // Use new constant
                const radius = THREE.MathUtils.randFloat(MIN_AI_RADIUS, MAX_AI_RADIUS); // Use new constants
                const snowballMesh = new THREE.Mesh(snowballGeometry, snowballMaterial);

                snowballMesh.castShadow = true;
                snowballMesh.receiveShadow = true;

                const range = GROUND_SIZE * 0.40;
                let x, z;
                do {
                    x = (Math.random() - 0.5) * range * 2;
                    z = (Math.random() - 0.5) * range * 2;
                } while (Math.sqrt(x * x + z * z) < 10.0);

                snowballMesh.position.set(x, radius, z);
                snowballMesh.scale.set(radius, radius, radius);

                // --- Store AI Data in userData ---
                snowballMesh.userData = {
                    radius: radius,
                    velocity: new THREE.Vector3(), // Each AI needs its own velocity
                    aiState: 'wandering',         // Initial state
                    aiTargetPos: new THREE.Vector3(), // Target wander position
                    // Set initial random wander timer
                    aiWanderTimer: THREE.MathUtils.randFloat(0.5, AI_WANDER_MAX_TIME / 2),
                    aiAvoidVector: new THREE.Vector3() // Vector for obstacle avoidance steering
                };
                // --- End Store AI Data ---

                scene.add(snowballMesh);
                aiSnowballs.push(snowballMesh); // Use new array name
            }
        }

        function createWarmPatches() {
            // --- Constants for Warm Patch Shape ---
            const baseWarmPatchRadius = 4.5; // Base average size (was the CircleGeometry radius)
            const warmPatchSegments = 16;    // Detail level
            const minWarmRadiusFactor = 0.6; // More variation maybe? (60%)
            const maxWarmRadiusFactor = 1.4; // More variation maybe? (140%)
            // --- End Constants ---

            const patchMaterial = new THREE.MeshStandardMaterial({
                map: warmGroundTexture,
                roughness: 0.9,
                side: THREE.DoubleSide // Good practice for modified geometry
            });

            for (let i = 0; i < WARM_PATCH_COUNT; i++) {
                // --- Create Base Geometry ---
                const patchGeometry = new THREE.CircleGeometry(baseWarmPatchRadius, warmPatchSegments);

                // --- Modify Vertices for Organic Shape ---
                const positions = patchGeometry.attributes.position;
                const vertex = new THREE.Vector3();

                for (let j = 0; j < positions.count; j++) {
                    vertex.fromBufferAttribute(positions, j);
                    const distance = vertex.length();

                    if (distance > 0.001) { // Skip center vertex
                        const randomFactor = THREE.MathUtils.randFloat(minWarmRadiusFactor, maxWarmRadiusFactor);
                        const newDistance = baseWarmPatchRadius * randomFactor;
                        vertex.normalize().multiplyScalar(newDistance);
                        positions.setXYZ(j, vertex.x, vertex.y, vertex.z);
                    }
                }
                positions.needsUpdate = true;
                patchGeometry.computeVertexNormals(); // Recalculate normals for standard material
                // --- End Modify Vertices ---


                const patch = new THREE.Mesh(patchGeometry, patchMaterial);
                const range = GROUND_SIZE * 0.45;
                patch.position.set(
                    (Math.random() - 0.5) * range * 2,
                    0.01, // Slightly above ground
                    (Math.random() - 0.5) * range * 2
                );
                patch.rotation.x = -Math.PI / 2; // Align with ground
                patch.receiveShadow = true; // Still receive shadows
                scene.add(patch);
                warmPatches.push(patch);
            }
        }

        function createObstacles() {
            // Pre-create geometries and materials outside the loop for efficiency
            // Existing Rock
            const rockBaseGeometry = new THREE.IcosahedronGeometry(1, 0); // Base radius 1
            const rockMaterial = new THREE.MeshStandardMaterial({ map: dirtTexture, roughness: 0.8 });

            // Existing Tree
            const treeTrunkBaseGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2.5, 8); // Base size
            const treeTrunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); // Brown
            const treeLeavesBaseGeometry = new THREE.ConeGeometry(1.2, 3, 8); // Base size
            const treeLeavesMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 }); // Forest Green

            // --- NEW: Fallen Log ---
            const logBaseGeometry = new THREE.CylinderGeometry(0.5, 0.5, 4.0, 12); // Base radius 0.5, length 4
            const logMaterial = new THREE.MeshStandardMaterial({ map: dirtTexture, roughness: 0.9 }); // Can reuse dirt/wood texture

            // --- NEW: Bush ---
            const bushBaseGeometry = new THREE.SphereGeometry(0.8, 16, 8); // Base sphere radius 0.8
            const bushMaterial = new THREE.MeshStandardMaterial({ color: 0x556B2F, roughness: 0.9 }); // Dark Olive Green

            for (let i = 0; i < OBSTACLE_COUNT; i++) {
                // Decide obstacle type randomly
                const obstacleTypeRoll = Math.random();
                let obstacleMesh;

                // Placement Coordinates (same for all types)
                const range = GROUND_SIZE * 0.45;
                const x = (Math.random() - 0.5) * range * 2;
                const z = (Math.random() - 0.5) * range * 2;



                // --- Choose Obstacle Type ---
                if (obstacleTypeRoll < 0.40) { // 40% Tree
                    // ... (Existing Tree creation logic with scaling - NO CHANGE HERE) ...
                    const tree = new THREE.Group();
                    const treeScaleFactor = THREE.MathUtils.randFloat(0.7, 1.6);
                    const trunkHeightScale = treeScaleFactor * THREE.MathUtils.randFloat(0.9, 1.1);
                    const trunkRadiusScale = treeScaleFactor * THREE.MathUtils.randFloat(0.8, 1.2);
                    const leavesScale = treeScaleFactor * THREE.MathUtils.randFloat(0.9, 1.1);
                    const trunk = new THREE.Mesh(treeTrunkBaseGeometry, treeTrunkMaterial);
                    const leaves = new THREE.Mesh(treeLeavesBaseGeometry, treeLeavesMaterial);
                    trunk.scale.set(trunkRadiusScale, trunkHeightScale, trunkRadiusScale);
                    leaves.scale.set(leavesScale, leavesScale, leavesScale);
                    const scaledTrunkHeight = 2.5 * trunkHeightScale;
                    const scaledTrunkRadius = 0.4 * trunkRadiusScale;
                    const scaledLeavesHeight = 3.0 * leavesScale;
                    trunk.position.y = scaledTrunkHeight / 2;
                    leaves.position.y = scaledTrunkHeight + (scaledLeavesHeight / 2) * 0.8;
                    trunk.castShadow = true; trunk.receiveShadow = true;
                    leaves.castShadow = true; leaves.receiveShadow = true;
                    tree.add(trunk); tree.add(leaves);
                    tree.position.set(x, 0, z);
                    scene.add(tree);
                    obstacleMesh = tree;
                    obstacleMesh.userData.radius = scaledTrunkRadius;
                    obstacleMesh.userData.center = new THREE.Vector3(x, scaledTrunkRadius * 0.5, z);
                    obstacleMesh.userData.type = 'tree'; // <-- Add type


                } else if (obstacleTypeRoll < 0.70) { // 30% Rock (40% + 30% = 70%)
                    // ... (Existing Rock creation logic with scaling - NO CHANGE HERE) ...
                    const rockBaseScale = THREE.MathUtils.randFloat(0.6, 2.2);
                    const rockYScaleFactor = THREE.MathUtils.randFloat(0.7, 1.3);
                    const rock = new THREE.Mesh(rockBaseGeometry, rockMaterial);
                    rock.scale.set(rockBaseScale, rockBaseScale * rockYScaleFactor, rockBaseScale);
                    rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                    const approxRockRadius = rockBaseScale * 1.0;
                    rock.position.set(x, approxRockRadius * 0.8, z);
                    rock.castShadow = true; rock.receiveShadow = true; scene.add(rock);
                    obstacleMesh = rock;
                    obstacleMesh.userData.radius = approxRockRadius;
                    obstacleMesh.userData.center = rock.position.clone();
                    obstacleMesh.userData.type = 'rock'; // <-- Add type


                } else if (obstacleTypeRoll < 0.90) { // 20% Fallen Log (70% + 20% = 90%)
                    const logScaleFactor = THREE.MathUtils.randFloat(0.8, 1.5);
                    const logCylinderRadius = 0.5 * logScaleFactor; // Actual radius of the cylinder
                    const logLength = 4.0 * logScaleFactor;
                    const log = new THREE.Mesh(logBaseGeometry, logMaterial);
                    log.scale.set(logScaleFactor, logScaleFactor, logScaleFactor);
                    const angleY = Math.random() * Math.PI * 2;
                    log.rotation.y = angleY;
                    log.rotation.z = Math.PI / 2;
                    log.position.set(x, logCylinderRadius, z); // Position based on actual radius
                    log.castShadow = true; log.receiveShadow = true;
                    scene.add(log);
                    obstacleMesh = log;
                    obstacleMesh.userData.collisionRadius = logLength / 2; // Radius for general collision check
                    obstacleMesh.userData.crushRadius = logCylinderRadius; // Radius for crush check
                    obstacleMesh.userData.center = log.position.clone();
                    obstacleMesh.userData.type = 'log'; // <-- Add type


                } else { // 10% Bush (90% + 10% = 100%)
                    // --- Bush Creation ---
                    // Create a small group of spheres to form a bush
                    const bushGroup = new THREE.Group();
                    const numBushSpheres = THREE.MathUtils.randInt(3, 6); // 3 to 6 spheres per bush
                    const bushBaseScale = THREE.MathUtils.randFloat(0.8, 1.4); // Overall size of the bush

                    for (let k = 0; k < numBushSpheres; k++) {
                        const sphereMesh = new THREE.Mesh(bushBaseGeometry, bushMaterial);
                        const sphereScale = bushBaseScale * THREE.MathUtils.randFloat(0.5, 1.0); // Individual sphere size variation
                        sphereMesh.scale.set(sphereScale, sphereScale, sphereScale);

                        // Position spheres clustered around the bush origin
                        const offsetX = (Math.random() - 0.5) * bushBaseScale * 0.8;
                        const offsetY = Math.random() * bushBaseScale * 0.5; // Slightly raise some spheres
                        const offsetZ = (Math.random() - 0.5) * bushBaseScale * 0.8;
                        sphereMesh.position.set(offsetX, offsetY, offsetZ);

                        sphereMesh.castShadow = true;
                        sphereMesh.receiveShadow = true;
                        bushGroup.add(sphereMesh);
                    }

                    // Position the entire bush group
                    bushGroup.position.set(x, 0, z); // Group origin at ground level
                    scene.add(bushGroup);
                    obstacleMesh = bushGroup;

                    // Collision Approximation: Use the overall base scale as radius
                    const approxBushRadius = bushBaseScale * 1.0; // A bit larger than base sphere radius
                    obstacleMesh.userData.radius = approxBushRadius;
                    obstacleMesh.userData.center = new THREE.Vector3(x, approxBushRadius * 0.5, z); // Center slightly above ground
                    // --- End Bush Creation ---

                    obstacleMesh.userData.type = 'bush'; // <-- Add type
                }

                // Add the created obstacle (mesh or group) to the main obstacles array
                if (obstacleMesh) {
                    obstacles.push(obstacleMesh);
                }
            } // End obstacle creation loop
        } // End createObstacles function

        // Uses larger patch size from previous step
        function createCollectableSnow() {
            // Base size for the organic patches before randomization
            const basePatchRadius = 1.2; // Average radius (adjust as needed)
            const patchSegments = 16; // Controls the detail/roundness (12-24 is good)
            const minRadiusFactor = 0.7; // Minimum distance factor (e.g., 70% of base radius)
            const maxRadiusFactor = 1.3; // Maximum distance factor (e.g., 130% of base radius)

            const patchMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide // Render both sides in case normals get weird
            });

            for (let i = 0; i < SNOW_PATCH_COUNT; i++) {
                // --- Create Base Geometry ---
                const patchGeometry = new THREE.CircleGeometry(basePatchRadius, patchSegments);

                // --- Modify Vertices for Organic Shape ---
                const positions = patchGeometry.attributes.position;
                const vertex = new THREE.Vector3(); // Temporary vector for calculations

                for (let j = 0; j < positions.count; j++) {
                    vertex.fromBufferAttribute(positions, j);

                    // Calculate distance from center (original radius for this vertex)
                    const distance = vertex.length();

                    // Don't modify the center vertex (distance is 0)
                    if (distance > 0.001) {
                        // Generate a random scaling factor for the radius
                        const randomFactor = THREE.MathUtils.randFloat(minRadiusFactor, maxRadiusFactor);
                        const newDistance = basePatchRadius * randomFactor; // Scale relative to base radius

                        // Calculate new position: Normalize original vector and scale by new distance
                        vertex.normalize().multiplyScalar(newDistance);

                        // Update the position buffer
                        positions.setXYZ(j, vertex.x, vertex.y, vertex.z);
                    }
                }
                positions.needsUpdate = true; // Tell Three.js the buffer has changed
                patchGeometry.computeVertexNormals(); // Recalculate normals for potentially better lighting/appearance (though basic material ignores it)
                // --- End Modify Vertices ---

                const patch = new THREE.Mesh(patchGeometry, patchMaterial);
                const range = GROUND_SIZE * 0.48;
                patch.position.set(
                    (Math.random() - 0.5) * range * 2,
                    0.02, // Slightly higher than warm patches
                    (Math.random() - 0.5) * range * 2
                );
                patch.rotation.x = -Math.PI / 2; // Rotate to lie flat
                scene.add(patch);
                collectableSnow.push(patch);
            }
            totalSnowPatches = collectableSnow.length;
        }

        // Uses nose indicator from previous step
        function createSnowball() {
            const snowballGeometry = new THREE.SphereGeometry(1, 32, 16); // Base radius 1 for easy scaling
            const snowballMaterial = new THREE.MeshStandardMaterial({
                // color: 0xffffff, // Remove or keep as 0xffffff (white multiplier)
                map: snowTexture,   // Apply the loaded snow texture
                roughness: 0.7,     // Adjust roughness as desired for snow appearance
                metalness: 0.0
            });
            snowball = new THREE.Mesh(snowballGeometry, snowballMaterial);
            snowball.castShadow = true;

            // --- REMOVE Nose Indicator ---
            // const noseRadius = 0.2;
            // const noseGeometry = new THREE.SphereGeometry(noseRadius, 12, 8);
            // const noseMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8 });
            // const noseMesh = new THREE.Mesh(noseGeometry, noseMaterial);
            // noseMesh.position.set(0, 0, 1.0 - noseRadius * 0.5);
            // noseMesh.castShadow = true;
            // snowball.add(noseMesh);
            // --- End Remove Nose ---

            // --- Create the Laser Pointer ---
            const laserGeometry = new THREE.CylinderGeometry(
                LASER_RADIUS, // radiusTop
                LASER_RADIUS, // radiusBottom
                LASER_LENGTH, // height
                8             // radialSegments (low is fine for thin cylinder)
            );
            // Use MeshBasicMaterial so it's bright red regardless of lighting
            const laserMaterial = new THREE.MeshBasicMaterial({
                color: LASER_COLOR
            });
            const laserMesh = new THREE.Mesh(laserGeometry, laserMaterial);

            // Rotate the cylinder so its length points along the snowball's local Z axis (forward)
            // By default, cylinder height is along local Y
            laserMesh.rotation.x = Math.PI / 2;

            // Position the laser's center.
            // It should start near the surface (radius 1 in local space) and extend forward.
            // The cylinder's center is at half its length.
            laserMesh.position.set(
                0,
                0,
                1.0 + LASER_LENGTH / 2 // Place center forward from surface (radius 1)
            );

            // Disable shadows for the laser itself (optional, it likely won't cast noticeable shadows anyway)
            laserMesh.castShadow = false;
            laserMesh.receiveShadow = false;

            // Add the laser as a child of the snowball
            snowball.add(laserMesh);
            // --- End Laser Pointer ---


            // Set initial position and scale based on starting radius
            snowball.position.set(0, INITIAL_SNOWBALL_RADIUS, 0);
            snowball.scale.set(INITIAL_SNOWBALL_RADIUS, INITIAL_SNOWBALL_RADIUS, INITIAL_SNOWBALL_RADIUS);
            scene.add(snowball);
            camera.lookAt(snowball.position); // Initial lookAt
        }

        function setupControls() {
            // Keyboard
            window.addEventListener('keydown', (event) => {
                if (keys.hasOwnProperty(event.key)) keys[event.key] = true;
            });
            window.addEventListener('keyup', (event) => {
                if (keys.hasOwnProperty(event.key)) keys[event.key] = false;
            });

            // --- Virtual Joystick Listeners ---
            joystickBase.addEventListener('touchstart', handleTouchStart, { passive: false });
            joystickBase.addEventListener('touchmove', handleTouchMove, { passive: false });
            joystickBase.addEventListener('touchend', handleTouchEnd);
            joystickBase.addEventListener('touchcancel', handleTouchEnd); // Treat cancel like end
            // --- End Joystick Listeners ---

            // REMOVED Gyro activation button listener
        }

        // --- Joystick Touch Handlers ---
        function handleTouchStart(event) {
            event.preventDefault(); // Prevent page scroll/zoom
            if (event.touches.length > 0) {
                joystickActive = true;
                const touch = event.touches[0];
                // Record start relative to the joystick base element's center
                const rect = joystickBase.getBoundingClientRect();
                joystickStartX = rect.left + rect.width / 2;
                joystickStartY = rect.top + rect.height / 2;

                // Initial move calculation (optional, can start from center)
                calculateJoystickMovement(touch.clientX, touch.clientY);
            }
        }

        function handleTouchMove(event) {
            event.preventDefault();
            if (!joystickActive || event.touches.length === 0) return;
            const touch = event.touches[0];
            calculateJoystickMovement(touch.clientX, touch.clientY);
        }

        function handleTouchEnd(event) {
            // No preventDefault needed here usually
            if (joystickActive) {
                joystickActive = false;
                // Reset handle position and movement values
                joystickHandle.style.transform = `translate(-50%, -50%)`; // Center it
                snowballMovement.forward = 0;
                snowballMovement.turn = 0;
            }
        }

        // In calculateJoystickMovement function:
        function calculateJoystickMovement(currentX, currentY) {
            const dx = currentX - joystickStartX;
            const dy = currentY - joystickStartY;
            let distance = Math.sqrt(dx * dx + dy * dy);

            const normalizedX = distance === 0 ? 0 : dx / distance;
            const normalizedY = distance === 0 ? 0 : dy / distance;

            // Calculate visual handle position (clamped)
            const visualDistance = Math.min(distance, joystickRadius);
            const visualX = normalizedX * visualDistance;
            const visualY = normalizedY * visualDistance;
            joystickHandle.style.transform = `translate(calc(-50% + ${visualX}px), calc(-50% + ${visualY}px))`;

            // Calculate Input Values with Dead Zone
            let inputDistanceNormalized = distance / joystickRadius;

            if (inputDistanceNormalized < JOYSTICK_DEAD_ZONE) {
                snowballMovement.forward = 0;
                snowballMovement.turn = 0;
            } else {
                // Calculate scale from dead zone edge to full radius
                let effectiveInputScale = (inputDistanceNormalized - JOYSTICK_DEAD_ZONE) / (1 - JOYSTICK_DEAD_ZONE);
                // Apply sensitivity and clamp
                effectiveInputScale = Math.min(effectiveInputScale * VIRTUAL_JOYSTICK_SENSITIVITY, 1.0);

                // --- Apply Quadratic Easing ---
                // This makes small stick movements result in even smaller input values,
                // allowing for finer control near the center.
                let easedScale = effectiveInputScale * effectiveInputScale;
                // --- End Easing ---

                // Map normalized direction vector components by the *eased* scale
                snowballMovement.forward = Math.max(-1, Math.min(1, -normalizedY * easedScale));
                // Stick Right = Positive X = Negative Turn
                snowballMovement.turn = Math.max(-1, Math.min(1, -normalizedX * easedScale));
            }
        }
        // --- End Joystick Touch Handlers ---

        // REMOVED handleOrientation
        // REMOVED requestGyroPermission

        // In updateSnowballMovement function:
        function updateSnowballMovement(deltaTime) {
            if (isGameOver || isGameWon) {
                snowballMovement.forward = 0;
                snowballMovement.turn = 0;
                snowballVelocity.multiplyScalar(FRICTION * FRICTION);
                return;
            }

            let isUsingJoystick = joystickActive;

            if (!isUsingJoystick) {
                snowballMovement.forward = 0;
                snowballMovement.turn = 0;
                if (keys.ArrowUp) snowballMovement.forward = 1;
                if (keys.ArrowDown) snowballMovement.forward = -1;
                if (keys.ArrowLeft) snowballMovement.turn = 1;  // Positive turn = Left
                if (keys.ArrowRight) snowballMovement.turn = -1; // Negative turn = Right
            }

            // Apply Rotation using appropriate speed
            const currentTurnSpeed = isUsingJoystick ? JOYSTICK_TURN_SPEED : KEYBOARD_TURN_SPEED;
            // Positive turn value results in counter-clockwise rotation (Left)
            // Negative turn value results in clockwise rotation (Right)
            snowball.rotation.y += snowballMovement.turn * currentTurnSpeed * deltaTime;

            // Apply Acceleration (Forward movement)
            const forwardDirection = new THREE.Vector3();
            snowball.getWorldDirection(forwardDirection);
            forwardDirection.y = 0;
            forwardDirection.normalize();

            const accelerationValue = snowballMovement.forward * KEYBOARD_MOVE_ACCELERATION;
            const accelerationVector = forwardDirection.multiplyScalar(accelerationValue * deltaTime);
            snowballVelocity.add(accelerationVector);

            // Apply Friction
            snowballVelocity.multiplyScalar(FRICTION);

            // Collision/Position Update
            const oldPosition = snowball.position.clone();
            snowball.position.addScaledVector(snowballVelocity, deltaTime);
            snowball.position.y = snowballRadius;
            handleObstacleCollisions(oldPosition);
            const halfGround = GROUND_SIZE / 2 - snowballRadius;
            snowball.position.x = Math.max(-halfGround, Math.min(halfGround, snowball.position.x));
            snowball.position.z = Math.max(-halfGround, Math.min(halfGround, snowball.position.z));
        }

        function removeObstacle(obstacle, index) {
            if (!obstacle) return;

            // Dispose of geometries and materials to free memory
            if (obstacle instanceof THREE.Group) {
                // Handle groups (like trees, bushes)
                obstacle.traverse((child) => {
                    if (child instanceof THREE.Mesh) {
                        if (child.geometry) child.geometry.dispose();
                        // Only dispose material if it's not shared, or handle sharing explicitly
                        // For simplicity now, assume materials might be shared and don't dispose them here
                        // if (child.material) child.material.dispose();
                    }
                });
            } else if (obstacle instanceof THREE.Mesh) {
                // Handle single meshes (like rocks, logs)
                if (obstacle.geometry) obstacle.geometry.dispose();
                // if (obstacle.material) obstacle.material.dispose();
            }

            // Remove from scene
            scene.remove(obstacle);

            // Remove from obstacles array using the provided index
            if (index >= 0 && index < obstacles.length) {
                obstacles.splice(index, 1);
            } else {
                console.warn("Could not remove obstacle from array: Invalid index");
            }
        }

        function handleObstacleCollisions(oldPosition) {
            const snowballWorldPos = snowball.position;

            // Iterate backwards for safe removal
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];

                // Basic check for necessary data
                if (!obstacle.userData || !obstacle.userData.center) continue;

                // Use specific collision radius for logs if available, otherwise default radius
                const obstacleCollisionRadius = obstacle.userData.collisionRadius || obstacle.userData.radius;
                if (obstacleCollisionRadius === undefined) continue; // Skip if no radius defined


                const obstacleCenter = obstacle.userData.center;
                const dx = snowballWorldPos.x - obstacleCenter.x;
                const dz = snowballWorldPos.z - obstacleCenter.z;
                const distanceSq = dx * dx + dz * dz; // Check only in XZ plane
                const radiiSum = snowballRadius + obstacleCollisionRadius;
                const radiiSumSq = radiiSum * radiiSum;

                // --- Check for Overlap ---
                if (distanceSq < radiiSumSq) {
                    // --- Check if Player Can Crush Obstacle ---
                    // Use specific crush radius for logs, otherwise default radius
                    const obstacleCrushRadius = obstacle.userData.crushRadius || obstacle.userData.radius;
                    const obstacleType = obstacle.userData.type || 'unknown';
                    let canCrush = false;

                    if (obstacleCrushRadius !== undefined) {
                        let requiredMultiplier = CRUSH_SIZE_MULTIPLIER;
                        // Make logs harder to crush (or indestructible if multiplier is huge)
                        if (obstacleType === 'log') {
                            requiredMultiplier = LOG_CRUSH_MULTIPLIER;
                        }

                        canCrush = snowballRadius > obstacleCrushRadius * requiredMultiplier;

                        // Add exceptions - e.g., maybe very large rocks are indestructible regardless of player size
                        // if (obstacleType === 'rock' && obstacleCrushRadius > SOME_LARGE_ROCK_THRESHOLD) {
                        //     canCrush = false;
                        // }
                    }


                    if (canCrush) {
                        // CRUSH IT!
                        console.log(`Crushing obstacle type: ${obstacleType}`);
                        removeObstacle(obstacle, i); // Remove from scene and array

                        // Optional: Add particle effect / sound here

                        // Continue checking other obstacles, don't apply collision response for this one
                        continue;

                    } else {
                        // --- Standard Collision Response (Cannot Crush) ---
                        const collisionNormal = new THREE.Vector3(dx, 0, dz).normalize();
                        const dot = snowballVelocity.dot(collisionNormal);

                        if (dot < 0) { // Moving towards obstacle
                            const counterVector = collisionNormal.multiplyScalar(-dot * 1.05); // Slightly stronger pushback
                            snowballVelocity.add(counterVector);
                        }

                        // Push snowball slightly out of collision zone to prevent sticking
                        const overlap = radiiSum - Math.sqrt(distanceSq);
                        const pushVector = collisionNormal.clone().multiplyScalar(overlap * 0.6); // Stronger push
                        snowball.position.add(pushVector);
                        snowball.position.y = snowballRadius; // Re-affirm height

                        // Don't break here - allow checking/colliding with other potential overlaps in one frame
                        // break; // Removed break statement
                    }
                    // --- End Standard Collision Response ---
                }
                // --- End Check for Overlap ---
            } // End loop through obstacles
        } // End handleObstacleCollisions

        // Uses updated collision check from previous step
        function checkCollectionsAndHazards(deltaTime) {
            if (isGameOver || isGameWon) return;

            const snowballPos = snowball.position;

            // === Phase 4: Snow Collection Logic ===
            // --- Adjust Collision Radius to Approximate Organic Shape ---
            // Use the average/base radius used during geometry creation
            const patchRadius = 1.2; // Matches basePatchRadius used in createCollectableSnow
            // --- End Adjust ---

            for (let i = collectableSnow.length - 1; i >= 0; i--) {
                const patch = collectableSnow[i];
                const dx = snowballPos.x - patch.position.x;
                const dz = snowballPos.z - patch.position.z;
                const distanceSq = dx * dx + dz * dz;
                const radiiSum = snowballRadius + patchRadius;

                if (distanceSq < radiiSum * radiiSum) {
                    // --- Dispose Geometry when removing ---
                    // Good practice if creating/destroying many geometries
                    if (patch.geometry) {
                        patch.geometry.dispose();
                    }
                    if (patch.material) {
                        // Material might be shared, but if unique per patch:
                        // patch.material.dispose();
                    }
                    // --- End Dispose ---

                    scene.remove(patch);
                    collectableSnow.splice(i, 1);
                    currentSnowCollected++;

                    const growth = COLLECT_GROWTH_FACTOR * (1 + currentSnowCollected / totalSnowPatches);
                    snowballRadius = Math.min(snowballRadius + growth, MAX_SNOWBALL_RADIUS);
                    updateSnowballSize();
                    updateHUD();

                    if (currentSnowCollected >= totalSnowPatches) {
                        winGame(); return;
                    }
                }
            }

            // === Player vs AI Snowball Collision & Absorption === // Renamed comment
            // Use renamed array: aiSnowballs
            for (let i = aiSnowballs.length - 1; i >= 0; i--) {
                const aiSnowballMesh = aiSnowballs[i]; // Use renamed array
                // Ensure userData and radius exist
                if (!aiSnowballMesh.userData || aiSnowballMesh.userData.radius === undefined) continue;

                const aiRadius = aiSnowballMesh.userData.radius; // Get radius from userData
                const distance = snowballPos.distanceTo(aiSnowballMesh.position);
                const collisionThreshold = snowballRadius + aiRadius;

                if (distance < collisionThreshold) {
                    console.log(`Collision! Player: ${snowballRadius.toFixed(2)}, AI: ${aiRadius.toFixed(2)}`);
                    if (snowballRadius > aiRadius) {
                        // Player absorbs AI snowball's growth
                        const aiGrowth = Math.max(0, aiRadius - INITIAL_SNOWBALL_RADIUS);
                        console.log(`Player absorbs ${aiGrowth.toFixed(2)} from AI ${i}`);
                        snowballRadius = Math.min(snowballRadius + aiGrowth, MAX_SNOWBALL_RADIUS);

                        // Reset AI snowball via userData
                        aiSnowballMesh.userData.radius = INITIAL_SNOWBALL_RADIUS;
                        // Scale/position update for AI happens in updateAISnowballs

                        updateSnowballSize(); // Update player visuals
                        updateHUD();

                    } else {
                        // AI snowball absorbs player's growth
                        const playerGrowth = Math.max(0, snowballRadius - INITIAL_SNOWBALL_RADIUS);
                        console.log(`AI ${i} absorbs ${playerGrowth.toFixed(2)} from Player`);

                        // Update AI radius via userData
                        let newAIRadius = aiRadius + playerGrowth;
                        newAIRadius = Math.min(newAIRadius, MAX_AI_RADIUS * 1.2); // Clamp AI size
                        aiSnowballMesh.userData.radius = newAIRadius;
                        // Scale/position update for AI happens in updateAISnowballs

                        // Reset player snowball
                        snowballRadius = INITIAL_SNOWBALL_RADIUS;

                        updateSnowballSize(); // Update player visuals
                        updateHUD();
                    }
                    break; // Only one collision per frame
                }
            }
            // === END: Player vs AI Interaction ===

            // === Phase 6: Hazard Mechanic (Melting) ===
            let isMelting = false;
            const warmPatchCollisionRadius = 4.5; // Unchanged
            for (const patch of warmPatches) {
                const dx = snowballPos.x - patch.position.x;
                const dz = snowballPos.z - patch.position.z;
                const distanceSq = dx * dx + dz * dz;
                const radiiSum = snowballRadius + warmPatchCollisionRadius;
                if (distanceSq < radiiSum * radiiSum) {
                    isMelting = true; break;
                }
            }
            if (isMelting) {
                snowballRadius = Math.max(snowballRadius - MELT_RATE * deltaTime, MIN_SNOWBALL_RADIUS);
                updateSnowballSize();
            }
        }

        function updateSnowballSize() {
            snowball.scale.set(snowballRadius, snowballRadius, snowballRadius);
            snowball.position.y = snowballRadius;
        }

        function updateCamera() {
            if (!snowball) return;
            const offset = new THREE.Vector3(0, 8 + snowballRadius * 2, 12 + snowballRadius * 2);
            const desiredPosition = snowball.position.clone().add(offset);
            camera.position.lerp(desiredPosition, 0.05);
            camera.lookAt(snowball.position);
        }

        function updateHUD() {
            if (isGameWon) {
                hudElement.innerText = `You Win! Collected ${currentSnowCollected} / ${totalSnowPatches}`;
            } else if (isGameOver) {
                hudElement.innerText = `Game Over!`;
            } else {
                hudElement.innerText = `Snow Collected: ${currentSnowCollected} / ${totalSnowPatches} | Radius: ${snowballRadius.toFixed(1)}`;
            }
        }

        function winGame() {
            console.log("You Win!");
            isGameWon = true;
            updateHUD();
            snowballVelocity.set(0, 0, 0);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            // Update joystick radius calculation in case size changes relative to window
            joystickRadius = joystickBase.offsetWidth / 2;
        }

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();

            // Update Player
            if (snowball) {
                updateSnowballMovement(deltaTime);
                // Note: checkCollectionsAndHazards now handles Player vs AI collision
                checkCollectionsAndHazards(deltaTime); // Checks Player vs Snow, Player vs AI, Player vs Warm
            }

            // Update AI
            updateAISnowballs(deltaTime); // Handles AI movement, AI vs AI collision, AI vs Warm

            updateCamera();
            render();
        }

        function render() {
            renderer.render(scene, camera);
        }

    </script>
</body>

</html>
